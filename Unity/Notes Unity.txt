Suppr: Library


using UnityEngine; => base
using UnityEditor; => Editor
using UnityEngine.UI; => UI
using TMPro; => UI.text +


Optimisation:
	Cashing = répétition -> stock (!= _tmp)
	operation couteuse -> stock
	dico/map == manager (camera, ...)
	except mieux car - secu (- rsc)


Attention : Script cumulable
		Update : begin, ..., end
		MonoBehaviour (=component) -> AUCUN constructor
		Stocker getComponent (~> Start)
		Game -> JAMAIS Free Aspect
		image = sprite MAIS raw image = texture
		échelle == 100 * unreal
		Use Task -> fais sortir de UnityEngine (=>System) donc g.o non
		x = right; y = up; z = forward


MonoBehaviour <- Behaviour <- Component <- Object (<- Object C#)
					 |> Transform <|


Awake ~= constructor
Start = BeginPlay
Update = Tick
Destroy = lui ou component

Ordre:
	Awake(-1) -> Start(0) -> Update(x) -> Destroy(.)
					  |-> LateUpdate, FixedUpdate, ...

LateUpdate:
	ex: camera follow player 
				  |-> get loc update
		|-> set loc late   

[SerializeField]: UPROPERTY
	pointeur vers compo = ObjectPtr + SubClassOf
	!! pour serial struct/class/... (natif) => [System.Serializable] avant def
	HEADER("") = group, RANGE( , ) = min/max/clamp

New:
	myObject = new GameObject(); (gameObject);
        myObject = new GameObject("Name", new System.Type[] {
            typeof(component)
        });
	   GameObject.CreatePrimitive(PrimitiveType.form);
  ou	gameObject.AddComponent<Class>(); (component)
  ou  Instantiate(GameObject/MonoBehaviour)
	Attention boucle

Prefab: (=blueprint)
	Pack/Unpack
	Prefabception

Canvas:
	Attention screen
	si error click : check Raycaster, EventSystem et RaycastTarget
	chaque Selectable (UI) parantage autres

Event:
	+= == AddListener()

PreProcess directive:
	#if
		...
	#endif

Wait/Sync: coroutine
	yield return xx -> att condition xx
	retourne TJR IEnumerator (Start can be)
	lancer -> StartCoroutine(Funct)
	  + StopCoroutine(Funct), StopAllCoroutines(), ...

Debug: 
	Debuf.log("");
	Debuf.logError("");
	void OnDrawGizmos()		!!perte frame
	{
		Gizmos.color...
		Gizmos.Draw...
	}

Camera:
	pls camera(component)
	last frame (first archi unity) == view
	clipping planes far == dist affichage (+réduire)
	!! anti-aliasing, post-process, background, 

Exception:
	throw new Exception...();
	=> custom except (override Message)
		try ()
		{}
		catch(except/custom)
		{ 
			stackTrace, Message
		}

Animation de var:
	expression => curve 
	AnimationCurve alpha -> alpha.Evaluate(Time.time)

DataAssets: (ScriptableObject)
	heritage => ScriptableObject + [CreateAssetMenu(fileName = "name asset")] avant def
	!! pour modif dynamic => creer instance (pas new)
		-> T _copy = ScriptableObject.Instantiate<T>(T _objCopy)
	  sinon repercute
	!! modif play se save

Dependance Component:
	[RequireComponent (typeof(NameCompo))] avant def
	-> ajoute auto le NameCompo sur object
	-> ne peut pas etre remove sans compo mere

Rotation:
	Euler => angle (pitch, yaw, roll)(Vector3) 	-> blocage cadran
	Quaternion => matrice 4,4 (Quaternion)		-> pas blocage
	convertir Euler -> Quaternion (=> Lerp, rotateToward,...)

Singleton:
	(Unity//Camera_GD//Singleton)
	manager, centraliser... (ex: camera, level,...)


Overlapping : Trigger (collider)
	component collider
	work: au moins 1 GO. <= rigidBody(solveur)
	      isTrigger = true -> trigger event (fantome)
			= false -> collision event (solid)
	tester collide -> test component
	custom layer: project settings/physics

EXO:
















